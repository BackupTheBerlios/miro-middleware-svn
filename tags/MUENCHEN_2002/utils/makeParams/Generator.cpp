// -*- c++ -*- ///////////////////////////////////////////////////////////////
//
// This file is part of Miro (The Middleware For Robots)
//
// (c) 1999, 2000, 2001
// Department of Neural Information Processing, University of Ulm, Germany
//
// $Id$
// 
//////////////////////////////////////////////////////////////////////////////


#include "Generator.h"

#include <iostream>

#define HEAD \
  "// -*- c++ -*- ///////////////////////////////////////////////////////////////\n" ## \
  "// This file was auto-generated by makeParameters\n" ## \
  "// $Id$\n" ## \
  "//////////////////////////////////////////////////////////////////////////////"

namespace
{
  QString head(HEAD);
};

void
Generator::addinclude(const QString& _include)
{
  include_.insert(_include);
}

void
Generator::addInclude(const QString& _Include)
{
  Include_.insert(_Include);
}

void
Generator::addStatic(const QString& _type, const QString& _name)
{
  staticData_.push_back(make_pair(_type, _name));
}

void
Generator::setFileName(const QString& _fileName)
{
  fileName_ = _fileName;
}

void 
Generator::setNamespace(const QString& _namespace)
{
  namespace_ = _namespace;
}

void
Generator::setName(const QString& _name)
{
  name_ = _name;
}

void
Generator::setParent(const QString& _parent)
{
  parent_ = _parent;
}

void 
Generator::addToConstructor(const QString& _ctor)
{
  ctor_.push_back(_ctor);
}

void 
Generator::addParameter(const Parameter& _parameter)
{
  parameter_.insert(_parameter);
}

void
Generator::generateHeader()
{
  if(name_.isEmpty())
    throw QString("No class name specified.");
  if(fileName_.isEmpty())
    throw QString("No file name specified.");

  int indent = 0;
  int step = 2;
  QString ws("                                                        ");

  cout << head << endl;
  cout << "#ifndef " << fileName_ << "_hh" << endl
       << "#define " << fileName_ << "_hh" << endl;

  QStringSet::const_iterator i;
  if (include_.size() > 0)
    cout << endl;
  for (i = include_.begin(); i != include_.end(); ++i)
    cout << "#include \""<< *i << "\"" << endl;
  if (Include_.size() > 0)
    cout << endl;
  for (i = Include_.begin(); i != Include_.end(); ++i)
    cout << "#include <"<< *i << ">" << endl;

  cout << endl;
  if (!namespace_.isEmpty()) {
    cout << namespace_ << endl
	 << "{" << endl;
    indent += step;
  }

  // debug ostream operator
  if (parent_.isEmpty()) {
    cout << ws.left(indent) << "struct " << name_ << ";" << endl
	 << ws.left(indent) << "std::ostream&" << endl
	 << ws.left(indent) << "operator << (std::ostream& ostr, const " << name_ << "& rhs);" << endl
	 << endl;
  }

  cout << ws.left(indent) << "struct " << name_;
  if (!parent_.isEmpty())
    cout << " : " << parent_;

  cout << endl
       << ws.left(indent) << "{" << endl;
  indent += step;
  
  if (!parent_.isEmpty())
    cout << ws.left(indent) << "typdef " << parent_ << " Super;" << endl
	 << endl;

  cout << ws.left(indent) << name_ << "();" << endl;
  if (parent_.isEmpty())
    cout << ws.left(indent) << "virtual ~"<< name_ << "();" << endl;
  cout << endl
       << ws.left(indent) << "virtual void operator () (const QNode& _node);" << endl
       << ws.left(indent) << "virtual void printToStream();" << endl
       << endl;

  // data members
  ParameterSet::const_iterator j;
  for (j = parameter_.begin(); j != parameter_.end(); ++j)
    cout << ws.left(indent) << j->type_ << " " << j->name_ << ";" << endl;


  // static data members
  if (staticData_.size() != 0)
    cout << endl;
  QStringPairVector::const_iterator k;
  for (k = staticData_.begin(); k != staticData_.end(); ++k)
    cout << ws.left(indent) << "static " << k->first << " " << k->second << ";" << endl;

   
  while (indent) {
    indent -= step;
    cout << ws.left(indent) << "};" << endl;
  }

  cout << "#endif // " << fileName_ << "_hh" << endl;
}

void
Generator::generateSource()
{
  if(name_.isEmpty())
    throw QString("No class name specified.");
  if(fileName_.isEmpty())
    throw QString("No file name specified.");

  int indent = 0;
  int step = 2;
  QString ws("                                                        ");

  QStringVector::const_iterator i;
  ParameterSet::const_iterator j;

  cout << head << endl;
  cout << "#include \"" << fileName_ << ".hh\"" << endl
       << endl
       << "#include <miro/qNodeParse>" << endl
       << "#include <iostream>" << endl
       << endl;

  if (!namespace_.isEmpty()) {
    cout << "namespace " << namespace_ << endl
	 << "{" << endl;
    indent += step;
  }

  // debug ostream operator
  if (parent_.isEmpty()) {
    cout << ws.left(indent) << "std::ostream&" << endl
	 << ws.left(indent) << "operator << (std::ostream& ostr, const " << name_ << "& rhs)" << endl
	 << ws.left(indent) << "{" << endl;
    indent += step;
    cout << ws.left(indent) << "rhs.printToStream(ostr);" << endl
	 << ws.left(indent) << "return ostr;" << endl;
    indent -= step;
    cout << ws.left(indent) << "}" << endl
	 << endl;
  }

  // static data members
  QStringPairVector::const_iterator k;
  for (k = staticData_.begin(); k != staticData_.end(); ++k)
    cout << ws.left(indent) << k->first << " " << name_ << "::" << k->second << ";" << endl;
  if (staticData_.size() != 0)
    cout << endl;

  // constructor
  cout << ws.left(indent) << name_ << "::" << name_ << "()";
  if (parameter_.size() > 0) {
    cout << " :";
    indent += 2;
 
    for (j = parameter_.begin(); j != parameter_.end(); ++j) {
      if (j != parameter_.begin())
	cout << ",";
      cout << endl
	   << ws.left(indent) << j->name_ << "(" << j->default_ << ")";
    }
    indent -= 2;
  }
  cout << endl 
       << ws.left(indent) << "{" << endl;

  indent += step;
  for (i = ctor_.begin(); i != ctor_.end(); ++i)
    cout << ws.left(indent) << *i << endl;
  indent -= step;

  cout << ws.left(indent) << "}" << endl
       << endl;

  // destructor
  if (parent_.isEmpty()) 
    cout << ws.left(indent) << name_ << "::~" << name_ << "()" << endl
	 << ws.left(indent) << "{}" << endl
	 << endl;

  // operator ()
  int preIndent = indent;
  cout << ws.left(indent) << "void" << endl
       << ws.left(indent) << name_ << "::operator() (const QNode& _node)" << endl
       << ws.left(indent) << "{" << endl;
  indent += step;

  if (!parent_.isEmpty())
    cout << ws.left(indent) << "Super::operator() (_node)" << endl
	 << endl;
  if (parameter_.size() > 0) {
    cout << ws.left(indent) << "if (!_node.isNull()) {" << endl;
    indent += step;
    cout << ws.left(indent) << "QDomNode n = _node.firstChild();" << endl
	 << ws.left(indent) << "while(!n.isNull() ) {" << endl;
    indent += step;

    for (j = parameter_.begin(); j != parameter_.end(); ++j) {
      QString name(j->name_);
      name[0] = name[0].upper();
      cout << ws.left(indent);
      if (j != parameter_.begin())
	cout << "else ";
      cout << "if (n.nodeName() == \"" << name << "\")" << endl;
      indent += step;
      cout << ws.left(indent) << j->name_ << " <<= n;" << endl;
      indent -= step;
    }

    indent -= step;
    cout << ws.left(indent) << "}" << endl
	 << ws.left(indent) << "n = n.nextSibling();" << endl;
  }
  while(indent > preIndent) {
    indent -= step;
    cout << ws.left(indent) << "}" << endl;
  }

  // stream output

  cout << endl
       << ws.left(indent) << "void" << endl
       << ws.left(indent) << name_ <<"::printToStream(std::ostream& ostr)" << endl
       << ws.left(indent) << "{" << endl;
  indent += step;

  if (!parent_.isEmpty())
    cout << ws.left(indent) << "Super::printToStream(ostr);" << endl
	 << endl;

  if (parameter_.size() > 0) {
    cout << ws.left(indent) << "ostr << ";
    indent += 5;
    for (j = parameter_.begin(); j != parameter_.end(); ++j) {
      if (j != parameter_.begin())
	cout << endl
	     << ws.left(indent) << "<< ";
      if (!j->description_.isEmpty())
	cout << "\"" << j->description_;
      else {
	QString name(j->name_);
	name[0] = name[0].upper();

	cout << "\"" << name;
      }
      cout << ": \" << " << j->name_;
      if (!j->measure_.isEmpty())
	cout << " << \"" << j->measure_ << "\"";
      cout << " << endl";
    }
    cout << ";" << endl;
    indent -= 5;
  }

  indent -= step;
  cout << ws.left(indent) << "}" << endl;

  if (!namespace_.isEmpty())
    cout << "};" << endl;
}

const QString&
Generator::name() const
{
  return name_;
}
