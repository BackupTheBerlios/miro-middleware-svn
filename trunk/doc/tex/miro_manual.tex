% detect interpreter: pdflatex or latex
\newif\ifpdf
\ifx\pdfoutput\undefined
\pdffalse
\else
\pdftrue
\fi

\documentclass[10pt]{book}

\usepackage{graphicx} % enhanced graphics usage
\usepackage{a4} % A4 paperformat
\usepackage{isolatin1} % for input of 8 bits character
\usepackage{makeidx} % enable indexing
\usepackage{verbatim} % better verbatim environment
\usepackage{epsfig}
\usepackage{xspace} % add extra space at the end of the word if necessary
\usepackage{color} % provides standard LaTeX colors
\usepackage{fancyhdr}
\usepackage{float} % float environment enhancements
\usepackage{alltt} % defines alltt environment which is like verbatim, but allows some additional formating
\usepackage{listings} % pritty print of code-listings
\ifpdf
% this package should be loaded last
\usepackage[colorlinks=true,
            pdfstartview=FitV,
            linkcolor=blue,
            citecolor=blue,
            urlcolor=blue]{hyperref}
\fi

\graphicspath{{../fig/}}

%% insert the common definitions
\input{tex_definitions}

%% special definitions
\setcounter{tocdepth}{3}

%% =============================================================================

\begin{document}
%\maketitle

\thispagestyle{empty}
\begin{center}
  \vfill
  \includegraphics[width=5in]{signature}\\
  \vspace{30 mm}
  {\Xbombastic \miro}\\
  \vspace{10 mm}
  {\LARGE \textbf{Manual}}\\
  \vspace{10 mm}
  \textbf{Version 0.9.4}\\
  \vspace{10 mm}
  \today\\
  \vfill
\end{center}

\newpage

\begin{center}
  \includegraphics[width=5in]{pincolla}
  \bigskip
  For more paintings, see {\tt http://www.bcn.fjmiro.es/}
\end{center}

\pagestyle{headings}

\newpage
\tableofcontents

%% =============================================================================

\chapter{Introduction}

\miro is a distributed object oriented framework for mobile robot
control, based on CORBA (Common Object Request Broker
Architecture) \cite{OMG:CORBA-standart} technology. The \miro core
components have been developed in C++ for Linux. But due to the
programming language independency of CORBA further components can be
written in any language and on any platform that provides CORBA
implementations.

The \miro core components have been developed under the aid of ACE
(Adaptive Communications Environment) \cite{ACE-Paper, ACE-Manual}, an
object oriented multi-platform framework for OS-independent
interprocess, network and real time communication. They use TAO (The
ACE ORB) \cite{TAO-paper} as their ORB (Object Request Broker), a
CORBA implementation designed for high performance and real time
applications. Therefore \miro should be easily portable to any other
OS, where ACE and TAO run on.  These are many Unix clones, Windows NT
and some real time operating systems.

\miro is currently available for the RWI B21 platform, the Activmedia
Pioneer 1, and the \sparrow architecture developed at the University
of Ulm, we are convinced, that other ports can be done straight
forward.

\miro was built since the existing robot control architectures didn't
suffice our needs of usability, reliability, scalability and
portability.

We used C++ due to its advantages in big projects, since it was
especially designed for big projects. We have learned the hard way,
that this is a serious requirement, for projects like a mobile robot
control architecture.

We use multi processing, multithreading and the CORBA technology since
most robotics applications are inherently concurrent and distributed.
The hardware devices, like sensors and actuators run concurrently and
due to the constant lack of computing power especially in computer
vision, tend to reside on multiple computers. And as soon as
cooperative behavior of multiple autonomous robots is of interest, the
system as a whole is distributed anyways.

%We used an object oriented approach, since real live objects are
%concerned. And on the other hand, OO is just state of the art and you
%need good arguments to start a new project ignoring object
%orientation.

And last but not least we use ACE and TAO since these are multi
platform, high performance libraries which proved to be very
sophisticated in terms of usability, portability and scalability. ---
Additionally, they are open source libraries. They haven't
disappointed us yet, to the contrary.

\section{The \miro Group}

The \miro core developers are (in alphabetical order):
\begin{itemize}
  \item Stefan Enderle
  \item Gerhard Kraetzschmar
  \item Gerd Mayer
  \item Guillem Pages
  \item Stefan Sablatn\"og
  \item Steffen Simon
  \item Hans Utz
\end{itemize}

\section{Installation and Setup}

Ask your system administrator if there exists a central installation,
or whether it would be more convenient to prepare a central
installation. Prerequisites for installing \miro is that you have a
running QT (Version $>$ 2.2.x) as well as an ACE/TAO installation.

\subsection{ACE and TAO Installation}
\label{sec::aceInstall}

ACE/TAO is a large software package with many configuration
options affecting the build process as well as its runtime
features. Therefore we summarize here our experience with the
ACE/TAO installation.

At the time of this writing we suggest always to use the
latest beta of ACE/TAO instead of the latest stable version ---
currently 5.2.2/1.2.2. TAO is under rapid development and \miro
utilizes some of its latest features (like the CORBA Notification
Service).

The options that should be set additionally in the {\tt
  platform\_macros.GNU} file (to be found under
$<$ACE-directory$>$/include/makeinclude/) are the following:

\begin{lstlisting}[frame=tb]{}
debug=0
qt_reactor=1
\end{lstlisting}

Additionally, for memory footprint reduction you might also add the
following:

\begin{lstlisting}[frame=tb]{}
DEFFLAGS=-DACE_USE_RCSID=0
ACE_COMPONENTS=FOR_TAO
\end{lstlisting}

We also recommend to read the installation instructions provided
by ACE carefully. We admit, the installation isn't entirely trivial.

To compile and run programs that use the ACE/TAO toolkit, also the
environment variables {\tt ACE\_ROOT} and {\tt TAO\_ROOT} need
to be set to the appropriate root directories of your ACE/TAO
installation. For the bash shell the following lines in your local
{\tt .bashrc} file should do the job:

\begin{lstlisting}[frame=tb]{}
export ACE_ROOT=<path to the ACE directory>
export TAO_ROOT=$ACE_ROOT/TAO
export LD_LIBRARY_PATH=$ACE_ROOT/ace/:$LD_LIBRARY_PATH
\end{lstlisting}
%%$

Note that if you use a non-standard Qt installation, also the
environment variable \texttt{QTDIR} has to point to the correct
installation directory of the Qt library.

\subsection{\miro installation}

This section is an extended version of the INSTALL file contained
within \miro. If you have problems installing \miro, read on.

\subsubsection{Requirements}

As already described above, you need the following packages in order
to compile \miro:
\begin{itemize}
\item ACE ($>$= 5.2.2): Please refer to the installation instruction
  in \ref{sec::aceInstall} for building and installing ACE. The source
  tarball and CVS access is available at:\\
  \texttt{http://www.cs.wustl.edu/$\sim$schmidt/ACE.html}.
\item TAO ($>$= 1.2.2): Building and installation is also described in
  section \ref{sec::aceInstall}. TAO downloads are available on:\\
  \texttt{http://www.theaceorb.com/}.
\item Qt ($>$= 2.2.4): Installation should be quite easy, as Qt uses a
  configure script for automatic system checks. Qt is installed on
  most modern Unix/Linux systems anyway, since KDE relies on
  it. Recent versions of Qt can be found at:\\
  \texttt{http://www.trolltech.com/}.
\end{itemize}

If you want to compile the wrapper classes for the speech detection
system, you also need:
\begin{itemize}
\item Speech tools: The Edinburgh Speech Tools Library is a collection
  of C++ class, functions and related programs for manipulating the
  sorts of objects used in speech processing. It is to provide the
  underlying classes in the Festival Speech System. We use version
  1.2.3 that can be retrieved from:\\
  \texttt{http://www.cstr.ed.ac.uk/projects/speech\_tools}
\item Festival: The Festival Speech Synthesis System is a general
  multi-lingual speech synthesis system developed at CSTR. We
  successfully used version 1.4.2. See:\\
  \texttt{http://www.cstr.ed.ac.uk/projects/festival/}
\item Sphinx: The CMU Sphinx Group Open Source Speech Recognition, a
  real-time, large vocabulary, speaker independent speech recognition
  system. We use version Sphinx2-0.4, downloaded from:\\
 \texttt{http://www.speech.cs.cmu.edu/sphinx}
\end{itemize}

Depending on your camera system, you may need libraries for the
IEEE 1394 (aka Firewire) support:
\begin{itemize} 
\item libraw1394: This library provides direct access to the IEEE 1394
  bus through the Linux 1394 subsystem's raw1394 user space
  interface. It can be found one it's homepage:\\
  \texttt{http://www.linux1394.org/}\\
  or on SourceForge:\\
  \texttt{http://sourceforge.net/projects/libraw1394/}
\item libdc1394: It is a library that is intended to provide a high
  level programming interface for application developers who wish to
  control IEEE 1394 based cameras that conform to the 1394-based
  Digital Camera Specification. Available via:\\
  \texttt{http://sourceforge.net/projects/libdc1394/}
\end{itemize}
Both libraries are available as compiled packages for the most modern
Linux systems too.

To build the documentation, your system should provide the following
tools:
\begin{itemize}
\item Doxygen: It is a JavaDoc like documentation system for C++, C,
  Java and IDL. It can generate an on-line HTML documentation
  extracted directly from the sources, which makes it much easier to
  keep the documentation consistent with the source code. You can
  download from the homepage:
  \texttt{http://www.stack.nl/\~dimitri/doxygen/}\\
  or again from SourceForge:\\
  \texttt{http://sourceforge.net/projects/doxygen/}
\item The LaTeX package (either pdflatex or latex and dvips, bibtex
  and makeindex -- available via one of the CTAN server, e.g.\ 
  \texttt{http://dante.ctan.org}) and the convert image convertsion
  utility from the ImageMagick package \\
  (\texttt{http://imagemagick.sourceforge.net/}).
\end{itemize}

\subsubsection{Download}

As if you read this text, you already have a version of \miro, but if
you want to update this version, or need some additional information,
please have a look at
\texttt{http://smart.informatik.uni-ulm.de/MIRO/index.html}

\subsubsection{Compilation}

\miro is now shipped with a configure script, so the package can be
installed with the usual steps:

\begin{lstlisting}[frame=tb]{}
./configure
make 
(make install)
\end{lstlisting}

The configure script looks automatically for the necessary and
optional software packages, and will stop or print a warning if some
of them are not found. If you install e.g.\ ACE in an unusual place,
you can pass the configure script some additional options like for
example \texttt{--with-ACE=<ACE-root-dir>}. For Qt, their are more
flexible command-line parameters, because Qt is often distributed over
several directories (like e.g.\ in a standard Debian installation). A
complete list of command-line options are accessible via
\texttt{./configure --help}.

Another way of telling the configure script where the packages are
installed is the use of environment variables. For the required
packages, these are \texttt{ACE\_ROOT}, \texttt{TAO\_ROOT} and
\texttt{QTDIR} point to the base directory of each package. Because
ACE and TAO need this environment variables anyway, this is the most
comfortable way to point to the directories. For the speech detection
wrappers classes, \texttt{SPEECH\_TOOLS\_ROOT}, \texttt{SPHINX\_ROOT}
and \texttt{FESTIVAL\_ROOT} are possible. It can be necessary, to let
the \texttt{LD\_LIBRARY\_PATH} point to all the libraries anyway.

If the configure script did not find the different packages anyhow, or
if your system require unusual options for compilation or linking that
the configure script does not know about, you can give configure
initial values for variables by setting them in the environment. Using
a Bourne-compatible shell, you can do that on the command line like
this:

\begin{lstlisting}[frame=tb]{}
CFLAGS=-O2 LIBS=-lposix ./configure
\end{lstlisting}

Or on systems that have the `env' program, you can do it like this:

\begin{lstlisting}[frame=tb]{}
env CPPFLAGS=-I/usr/local/include LDFLAGS=-s ./configure
\end{lstlisting}

On runtime, some applications rely on two environment variables,
namely \texttt{MIRO\_ROOT} (the base directory) and \texttt{MIRO\_LOG}
(directory, where logging data are stored), so please set these
variables to the appropriate values too.

Additionally, you can enable or disable several features, like the
support for different robot platforms and for different video devices.

Supported robot platforms:
\begin{itemize}
\item The B21 port is the oldest one and should therefore be the most
  stable, regarding the interfaces. All of the robots hardware
  components are supported by \miro.
\item The Sparrow99 robots are our soccer robots. They are our testbed
  for multi-robot programming. Therefore most new technology is first
  tested on this platform. So even as you do not have a Sparrow99
  robot (we built them ourselfs), it might be interesting to look at
  the sources for this robot if you are looking for group
  communication technology etc.
\item The Pioneer1 platform is a complete port for the ActiveMedia
  robot series, based on the PSOS, P2OS and AROS protocols. But we
  could only test and extend it to the platforms available to us.
  \begin{itemize}
  \item The old Pioneer1 is supported, but lacks maintenance, as our
    model is not used at the lab anymore.
  \item The Performance PeopleBot is in active development and already
    mostly complete. Motors, Sonars, Bumpers and Video are working.
    PanTilt and Gripper are experimental, Zoom is to come next.
  \end{itemize}
\end{itemize}

Supported video devices:
\begin{itemize}
\item Bttv Frame Grabbers: These frame grabber cards are supported via
  video for Linux.  This is the standard way of connecting standard
  analog video cameras to the computer.
\item Firewire Digital Cameras: \miro supports the fire wire digital
  camera protocol using libraw1394 and libdc1394.
\item Matrox Meteor Frame Grabbers: These rather old frame grabber
  cards are also supported by \miro. This device however, is mostly
  unmaintained.
\end{itemize}

Finally, you can choose if the documentation should be build or not.
Even if you decide not to build it, but the configure script found all
the necessary tools, the Makefiles are prepared. So you can go to the
\texttt{doc/tex} and \texttt{doc/html} directory later on and build
the documentation there with a simple make.

After running the configure script, \miro show up a summary of what
will be compiled and which features will not. If this is not what you
desired, please check the messages coming up during the configure run
for packages, \miro did not find.

\subsubsection{Installation}

\miro can be installed with the a simple:

\begin{lstlisting}[frame=tb]{}
make install
\end{lstlisting}

By default, the package's files will be installed in \texttt{/usr/local/bin},
\texttt{/usr/local/lib} etc.  You can specify an installation prefix other
than \texttt{/usr/local} by giving configure the option
\texttt{--prefix=PATH} (note: if you use the prefix-option, you should
install \miro actually, otherwise libtool may look for the library in
the installation directory and therefore do not find it).

Beside that, \miro can be used already without installation. Therefore,
a make run install the libraries and the binaries during the
compilation into the \texttt{lib/} and \texttt{bin/} directory. This
enlarges the \miro directory, but can be quite useful, if you work on
\miro itself and a derived application at the same time.

Moreover with this trick it is possible, to use different \miro
versions in parallel at the same time. Therefore the build process
allow to compile the package in a different directory. Assuming you
have extracted \miro in a directory called \texttt{Miro}, you can
build it in two different directories with miscellaneous options:

\begin{lstlisting}[frame=tb]{}
mkdir Miro.B21
cd Miro.B21
../Miro/configure --enable-B21
make
cd ..
mkdir Miro.Sparrow99
cd Miro.Sparrow99
../Miro/configure --enable-Sparrow99
make
\end{lstlisting}

\subsubsection{Developer information}

The build-process within \miro is done using automake, autoconf and
libtool. Normally, there is no need to use these programs, as of
running the configure script is the only thing a user have to do.

The configure shell script attempts to guess correct values for
various system-dependent variables used during compilation. It uses
those values to create a Makefile in each directory of the package.
It also create one config.h file containing system-dependent
definitions that can be used in the source file to allow appropriate
compilation:

\begin{lstlisting}[frame=tb]{}
#ifdef HAVE_CONFIG_H
#include <config.h>
#endif
...
#ifdef MIRO_HAS_1394
...
#endif
\end{lstlisting}

If you want to change something within \miro like for example adding
additional files or directories, you have to change the proper
\texttt{Makefile.am}. Do \textbf{not} change the \texttt{Makefile.in}
or even the final \texttt{Makefile}, because changes there are getting
lost are the next automake run. The same applies, if you want to
change the behaviour of the configure script itself, for example to
detect new software packages or special version information, you have
to change the \texttt{configure.ac} and \textbf{not} the
\texttt{configure} file itself.

Assuming that you have written appropriate \texttt{Makefile.am} and
\texttt{configure.ac} files, you should be able to build your project
by entering the following commands:

\begin{lstlisting}[frame=tb]{}
aclocal -I config
autoheader
automake
autoconf
./configure
\end{lstlisting}

For every consecutive step, you can simply call the resulting
\texttt{config.status} script, that rerun the configure procedure with
the used configuration values.

Normally, it should be enough, to use the available examples within
\miro to add some small additions to the build process, but sometimes
a deeper understanding of the used tools might be necessary. Please
have a look at the manuals, available e.g.\ directly from the GNU
homepage: \texttt{http://www.gnu.org/manual/} or read the freely
available book on \texttt{http://sources.redhat.com/autobook/}.

\section{\miro Directory Structure}

\miro comes with the full source code and documentation as well as a
set of test programs and examples that should facilitate your first
steps when writing your own programs. To help you navigate through the
directory tree of a \miro distribution, we give a brief overview of
the directories present in the \miro root directory:

\begin{description}
\item[bin:]
  This directory contains links to the binaries of \miro.
  For an explanation of the individual binaries, see Chapter
  \ref{sec:services} about the robot services.
\item[doc:]
  Here, the available documentation is gathered. In the
  subdirectory {\tt tex} you find the postscript version of this
  manual and in the directory {\tt html} resides the auto generated
  online documentation of all \miro classes and their methods
  (the starting page of this documentation resides at: \\
  {\tt \$MIRO\_ROOT/doc/html/idl/index.html} respectively \\
  {\tt \$MIRO\_ROOT/doc/html/cpp/index.html}).
\item[etc:]
  Config files for the individual robots.
\item[examples:]
  Examples on how to use individual interfaces of \miro. If you want
  to write your own programs utilizing the \miro framework, this is a
  good place to look for inspirations.
\item[idl:]
  The IDL sources of the CORBA interfaces and data types.
\item[performance-tests:]
  Some tests that measure the performance of \miro's
  services. --- Not too much there at the moment.
\item[scripts:]
  Utilities for source code formatting and handling sequences of
  datafiles.
\item[src:]
  Here, all sources of the \miro services reside. New services for
  further robot platforms should go in here.
\item[templates:]
  Templates for Makefiles and the headers for source files. Copy the
  corresponding template, if you want to start a new subproject within
  the \miro source hierarchy. If you start your own new project on top
  of \miro, the Makefile templates might still be useful for you. They
  handle all the stuff concerning ACE/TAO and the multi-platform build
  process. See Chapter \ref{sec:makefile} for details.
\item[tests:]
  Small test programs to monitor or test isolated interfaces of the
  \miro robot control architecture.
\item[utils:]
  Utilities made for convenience. No magic to be expected here.
\end{description}

%=============================== Tutorial ====================================

\input{definitions}
\input{using}
\input{servers}
\input{clients}
\input{writing_a_client}
\input{parameters}
\input{video}
\input{behaviourEngine}
\input{writing_a_server}

%------------------------------------------------------------------------------


\bibliography{miro_manual}
\printindex

\end{document}
