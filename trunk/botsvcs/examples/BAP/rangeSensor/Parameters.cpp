// -*- c++ -*- ///////////////////////////////////////////////////////////////
// This file was auto-generated by MakeParameters
//////////////////////////////////////////////////////////////////////////////
#include "Parameters.h"

#include <miro/TimeHelper.h>
#include <miro/XmlParse.h>
#include <qdom.h>

namespace
{
  using Miro::operator<<=;
  using Miro::operator>>=;
  using Miro::operator<<;
};

RangeSensorBehaviourParameters::RangeSensorBehaviourParameters() :
  sensorName("Infrared"),
  history(0,5)
{
}

void
RangeSensorBehaviourParameters::operator <<= (const QDomNode& _node)
{
  this->Super::operator <<= (_node);

  if (!_node.isNull()) {
    QDomNode n = _node.firstChild();
    while(!n.isNull() ) {
      QDomElement e = n.toElement();
      if( !e.isNull() ) {
        QDomAttr a = e.attributeNode("name");
        if (!a.isNull()) {
          QString i = a.value();
          if (i == "SensorName") {
            this->sensorName <<= n;
          }
          else if (i == "History") {
            this->history <<= n;
          }
        }
      }
      n = n.nextSibling();
    }
  }
}
QDomElement
RangeSensorBehaviourParameters::operator >>= (QDomNode& _node) const
{
  QDomElement e = Super::operator >>= (_node);
  QDomElement g;

  g = (this->sensorName >>= e);
  g.setAttribute("name", "SensorName");
  g = (this->history >>= e);
  g.setAttribute("name", "History");

  return e;
}

void
RangeSensorBehaviourParameters::printToStream(std::ostream& ostr) const
{
  Super::printToStream(ostr);

  ostr << "SensorName: " << sensorName << std::endl
       << "History: " << history << "sec" << std::endl;
}

RangeSensorWallFollowParameters::RangeSensorWallFollowParameters() :
  translation(400),
  rotation(Miro::deg2Rad(45)),
  minDistance(500),
  maxDistance(400)
{
  sensorName = "Infrared";
}

void
RangeSensorWallFollowParameters::operator <<= (const QDomNode& _node)
{
  this->Super::operator <<= (_node);

  if (!_node.isNull()) {
    QDomNode n = _node.firstChild();
    while(!n.isNull() ) {
      QDomElement e = n.toElement();
      if( !e.isNull() ) {
        QDomAttr a = e.attributeNode("name");
        if (!a.isNull()) {
          QString i = a.value();
          if (i == "Translation") {
            this->translation <<= n;
          }
          else if (i == "Rotation") {
            this->rotation <<= n;
            this->rotation = Miro::deg2Rad(this->rotation);
          }
          else if (i == "MinDistance") {
            this->minDistance <<= n;
          }
          else if (i == "MaxDistance") {
            this->maxDistance <<= n;
          }
        }
      }
      n = n.nextSibling();
    }
  }
}
QDomElement
RangeSensorWallFollowParameters::operator >>= (QDomNode& _node) const
{
  QDomElement e = Super::operator >>= (_node);
  QDomElement g;

  g = (this->translation >>= e);
  g.setAttribute("name", "Translation");
  g = (Miro::rad2Deg(this->rotation) >>= e);
  g.setAttribute("name", "Rotation");
  g = (this->minDistance >>= e);
  g.setAttribute("name", "MinDistance");
  g = (this->maxDistance >>= e);
  g.setAttribute("name", "MaxDistance");

  return e;
}

void
RangeSensorWallFollowParameters::printToStream(std::ostream& ostr) const
{
  Super::printToStream(ostr);

  ostr << "Translation: " << translation << "mm/s" << std::endl
       << "Rotation: " << Miro::rad2Deg(rotation)
 << "/s" << std::endl
       << "MinDistance: " << minDistance << "mm" << std::endl
       << "MaxDistance: " << maxDistance << "mm" << std::endl;
}

RangeSensorAvoidParameters::RangeSensorAvoidParameters() :
  minDistance(500),
  haltDistance(300),
  lateralDistance(500),
  translation(200),
  rotation(Miro::deg2Rad(45)),
  sensorName("Sonar")
{
}

void
RangeSensorAvoidParameters::operator <<= (const QDomNode& _node)
{
  this->Super::operator <<= (_node);

  if (!_node.isNull()) {
    QDomNode n = _node.firstChild();
    while(!n.isNull() ) {
      QDomElement e = n.toElement();
      if( !e.isNull() ) {
        QDomAttr a = e.attributeNode("name");
        if (!a.isNull()) {
          QString i = a.value();
          if (i == "MinDistance") {
            this->minDistance <<= n;
          }
          else if (i == "HaltDistance") {
            this->haltDistance <<= n;
          }
          else if (i == "LateralDistance") {
            this->lateralDistance <<= n;
          }
          else if (i == "Translation") {
            this->translation <<= n;
          }
          else if (i == "Rotation") {
            this->rotation <<= n;
            this->rotation = Miro::deg2Rad(this->rotation);
          }
          else if (i == "SensorName") {
            this->sensorName <<= n;
          }
        }
      }
      n = n.nextSibling();
    }
  }
}
QDomElement
RangeSensorAvoidParameters::operator >>= (QDomNode& _node) const
{
  QDomElement e = Super::operator >>= (_node);
  QDomElement g;

  g = (this->minDistance >>= e);
  g.setAttribute("name", "MinDistance");
  g = (this->haltDistance >>= e);
  g.setAttribute("name", "HaltDistance");
  g = (this->lateralDistance >>= e);
  g.setAttribute("name", "LateralDistance");
  g = (this->translation >>= e);
  g.setAttribute("name", "Translation");
  g = (Miro::rad2Deg(this->rotation) >>= e);
  g.setAttribute("name", "Rotation");
  g = (this->sensorName >>= e);
  g.setAttribute("name", "SensorName");

  return e;
}

void
RangeSensorAvoidParameters::printToStream(std::ostream& ostr) const
{
  Super::printToStream(ostr);

  ostr << "MinDistance: " << minDistance << "mm" << std::endl
       << "HaltDistance: " << haltDistance << "mm" << std::endl
       << "LateralDistance: " << lateralDistance << "mm" << std::endl
       << "Translation: " << translation << "mm/s" << std::endl
       << "Rotation: " << Miro::rad2Deg(rotation)
 << "/s" << std::endl
       << "SensorName: " << sensorName << std::endl;
}


