// -*- c++ -*- ///////////////////////////////////////////////////////////////
//
// This file is part of Miro (The Middleware For Robots)
//
// (c) 2000, 2001, 2002
// Department of Neural Information Processing, University of Ulm, Germany
//
// $Id$
// $Date$
// 
//////////////////////////////////////////////////////////////////////////////

#ifdef HAVE_CONFIG_H
#include <config.h>
#endif

#include "Generator.h"

#include <qfileinfo.h>

#include <iostream>

#include <sys/time.h>

namespace
{
  QString head(QString("// -*- c++ -*- ///////////////////////////////////////////////////////////////\n") +
	       QString("// This file was auto-generated by MakeParameters\n") + 
	       QString("//////////////////////////////////////////////////////////////////////////////"));
  QString spaces("                                                        ");
};

Generator::Generator()
{
  addInclude("iostream");
  addInclude("qdom.h");

}

void
Generator::addinclude(const QString& _include)
{
  include_.insert(_include);
}

void
Generator::addInclude(const QString& _Include)
{
  Include_.insert(_Include);
}

void
Generator::addSrcInclude(const QString& _Include)
{
  srcInclude_.insert(_Include);
}

void
Generator::addForwardDeclaration(const QString& _decl)
{
  forwardDeclaration_.insert(_decl);
}

void
Generator::addLocalForwardDeclaration(const QString& _decl)
{
  localForwardDeclaration_.insert(_decl);
}

void
Generator::addClass(const QString& _group, const Class& _class)
{
  class_.push_back(_class);
  QString nameSpace;
  QStringVector::const_iterator first, last = namespace_.end();
  for (first = namespace_.begin(); first != last; ++first)
    nameSpace += (*first) + "::";
  class_.back().setNameSpace(nameSpace);
  groups_.insert(std::make_pair(_group, _class));
}

void
Generator::setBaseName(const QString& _fileName)
{
  fileName_ = _fileName;
}

void
Generator::setHeaderExtension(const QString& _extensionName)
{
  extensionName_ = _extensionName;
}

void 
Generator::addNamespace(const QString& _namespace)
{
  namespace_.push_back(_namespace);
}

void
Generator::generateHeader(std::ostream& ostr) const
{
  if(fileName_.isEmpty())
    throw QString("No file name specified.");

  struct timeval t;
  struct timezone z;
  gettimeofday(&t, &z);

  int indent = 0;

  QFileInfo fileName(fileName_);
  QString includeGuard(fileName.baseName() + "_" + extensionName_);

  ostr << head << std::endl;
  ostr << "#ifndef " << includeGuard
       << "_" << t.tv_usec // make it truely unique
       << std::endl
       << "#define " << includeGuard
       << "_" << t.tv_usec // make it truely unique
       << std::endl;

  QStringSet::const_iterator i;
  if (include_.size() > 0)
    ostr << std::endl;
  for (i = include_.begin(); i != include_.end(); ++i)
    ostr << "#include \""<< *i << "\"" << std::endl;
  if (Include_.size() > 0)
    ostr << std::endl;
  for (i = Include_.begin(); i != Include_.end(); ++i)
    ostr << "#include <"<< *i << ">" << std::endl;

  ostr << std::endl;

  if (forwardDeclaration_.size() != 0) {
    ostr << "// forward declarations" << std::endl;
    for (i = forwardDeclaration_.begin(); i != forwardDeclaration_.end(); ++i)
      ostr << "class " << *i << ";" << std::endl;
    ostr << std::endl;
  }

  QStringVector::const_iterator f, l = namespace_.end();
  for (f = namespace_.begin(); f != l; ++f) {
    ostr << spaces.left(indent) << "namespace " <<  *f << std::endl
	 << spaces.left(indent) << "{" << std::endl;
    indent += STEP;
  }

  if (localForwardDeclaration_.size() != 0) {
    ostr << "// forward declarations" << std::endl;
    for (i = localForwardDeclaration_.begin(); i != localForwardDeclaration_.end(); ++i)
      ostr << "class " << *i << ";" << std::endl;
    ostr << std::endl;
  }

  ClassVector::const_iterator first, last = class_.end();
  for (first = class_.begin(); first != last; ++first) {
    if (first != class_.begin())
      ostr << std::endl;
    if (!first->isDummy())
      first->generateHeader(ostr, indent);
  }
   
  while (indent) {
    indent -= STEP;
    ostr << spaces.left(indent) << "};" << std::endl;
  }

  ostr << std::endl
       << "#endif // " << fileName_ << "_" << extensionName_ << std::endl;
}

void
Generator::generateSource(std::ostream& ostr) const
{
  if(fileName_.isEmpty())
    throw QString("No file name specified.");

  int indent = 0;

  ostr << head << std::endl;
  ostr << "#include \"" << fileName_ << "." << extensionName_ << "\"" << std::endl
       << std::endl;

  QStringSet::const_iterator i;
  for (i = srcInclude_.begin(); i != srcInclude_.end(); ++i)
    ostr << "#include <"<< *i << ">" << std::endl;

  ostr << "#include <miro/XmlParse.h>" << std::endl
       << "#include <qdom.h>" << std::endl
       << std::endl;

  // match the operator <<= from Miro into local namespace
  if (namespace_.size() == 0 || 
      namespace_.front() != QString("Miro")) {
    ostr << "namespace" << std::endl
	 << "{" << std::endl
	 << "  using Miro::operator<<=;" << std::endl
	 << "  using Miro::operator>>=;" << std::endl
	 << "  using Miro::operator<<;" << std::endl
	 << "};" << std::endl
	 << std::endl;
  }

  QStringVector::const_iterator f, l = namespace_.end();
  for (f = namespace_.begin(); f != l; ++f) {
    ostr << spaces.left(indent) << "namespace " <<  *f << std::endl
	 << spaces.left(indent) << "{" << std::endl;
    indent += STEP;
  }

  ClassVector::const_iterator first, last = class_.end();
  for (first = class_.begin(); first != last; ++first) {
    if (first != class_.begin())
      ostr << std::endl;
    if (!first->isDummy())
      first->generateSource(ostr, indent);
  }

  while (indent) {
    indent -= STEP;
    ostr << spaces.left(indent) << "};" << std::endl;
  }

}

void
Generator::getGroupedClasses(const QString& _group, 
			     GroupMap::const_iterator& _first, GroupMap::const_iterator& _last) const
{
  _first = groups_.lower_bound(_group);
  _last = groups_.upper_bound(_group);
}

const Class *
Generator::getClass(const QString& _name) const
{
  ClassVector::const_iterator first, last = class_.end();
  for (first = class_.begin(); first != last; ++first)
    if (first->name() == _name ||
	first->name() + "Parameters" == _name ||
	first->fullName() == _name)
#if GCC_MAJOR_VERSION > 2
      return first.base();
#else
      return first;
#endif
  return NULL;
}
