// -*- c++ -*- ///////////////////////////////////////////////////////////////
//
// This file is part of Miro (The Middleware For Robots)
//
// (c) 2000, 2001, 2002
// Department of Neural Information Processing, University of Ulm, Germany
//
// $Id$
// $Date$
// 
//////////////////////////////////////////////////////////////////////////////

#include "Generator.h"

#include <qfileinfo.h>

#include <iostream>

#include <sys/time.h>

#define HEAD \
  "// -*- c++ -*- ///////////////////////////////////////////////////////////////\n" ## \
  "// This file was auto-generated by makeParameters\n" ## \
  "//////////////////////////////////////////////////////////////////////////////"

namespace
{
  QString head(HEAD);
  QString spaces("                                                        ");
};

Generator::Generator()
{
  addInclude("iostream");
  addInclude("qdom.h");

}

void
Generator::addinclude(const QString& _include)
{
  include_.insert(_include);
}

void
Generator::addInclude(const QString& _Include)
{
  Include_.insert(_Include);
}

void
Generator::addSrcInclude(const QString& _Include)
{
  srcInclude_.insert(_Include);
}

void
Generator::addForwardDeclaration(const QString& _decl)
{
  forwardDeclaration_.insert(_decl);
}

void
Generator::addLocalForwardDeclaration(const QString& _decl)
{
  localForwardDeclaration_.insert(_decl);
}

void
Generator::addClass(const QString& _group, const Class& _class)
{
  class_.push_back(_class);
  groups_.insert(std::make_pair(_group, _class));
}

void
Generator::setBaseName(const QString& _fileName)
{
  fileName_ = _fileName;
}

void
Generator::setHeaderExtension(const QString& _extensionName)
{
  extensionName_ = _extensionName;
}

void 
Generator::addNamespace(const QString& _namespace)
{
  namespace_.push_back(_namespace);
}

void
Generator::generateHeader(ostream& ostr) const
{
  if(fileName_.isEmpty())
    throw QString("No file name specified.");

  struct timeval t;
  struct timezone z;
  gettimeofday(&t, &z);

  int indent = 0;

  QFileInfo fileName(fileName_);
  QString includeGuard(fileName.baseName(false) + "_" + extensionName_);

  ostr << head << endl;
  ostr << "#ifndef " << includeGuard
       << "_" << t.tv_usec // make it truely unique
       << endl
       << "#define " << includeGuard
       << "_" << t.tv_usec // make it truely unique
       << endl;

  QStringSet::const_iterator i;
  if (include_.size() > 0)
    ostr << endl;
  for (i = include_.begin(); i != include_.end(); ++i)
    ostr << "#include \""<< *i << "\"" << endl;
  if (Include_.size() > 0)
    ostr << endl;
  for (i = Include_.begin(); i != Include_.end(); ++i)
    ostr << "#include <"<< *i << ">" << endl;

  ostr << endl;

  if (forwardDeclaration_.size() != 0) {
    ostr << "// forward declarations" << endl;
    for (i = forwardDeclaration_.begin(); i != forwardDeclaration_.end(); ++i)
      ostr << "class " << *i << ";" << endl;
    ostr << endl;
  }

  QStringVector::const_iterator f, l = namespace_.end();
  for (f = namespace_.begin(); f != l; ++f) {
    ostr << spaces.left(indent) << "namespace " <<  *f << endl
	 << spaces.left(indent) << "{" << endl;
    indent += STEP;
  }

  if (localForwardDeclaration_.size() != 0) {
    ostr << "// forward declarations" << endl;
    for (i = localForwardDeclaration_.begin(); i != localForwardDeclaration_.end(); ++i)
      ostr << "class " << *i << ";" << endl;
    ostr << endl;
  }

  ClassVector::const_iterator first, last = class_.end();
  for (first = class_.begin(); first != last; ++first) {
    if (first != class_.begin())
      ostr << endl;
    if (!first->isDummy())
      first->generateHeader(ostr, indent);
  }
   
  while (indent) {
    indent -= STEP;
    ostr << spaces.left(indent) << "};" << endl;
  }

  ostr << endl
       << "#endif // " << fileName_ << "_" << extensionName_ << endl;
}

void
Generator::generateSource(ostream& ostr) const
{
  if(fileName_.isEmpty())
    throw QString("No file name specified.");

  int indent = 0;

  ostr << head << endl;
  ostr << "#include \"" << fileName_ << "." << extensionName_ << "\"" << endl
       << endl;

  QStringSet::const_iterator i;
  for (i = srcInclude_.begin(); i != srcInclude_.end(); ++i)
    ostr << "#include <"<< *i << ">" << endl;

  ostr << "#include <miro/XmlParse.h>" << endl
       << "#include <qdom.h>" << endl
       << endl;

  // match the operator <<= from Miro into local namespace
  if (namespace_.size() == 0 || 
      namespace_.front() != QString("Miro")) {
    ostr << "namespace" << endl
	 << "{" << endl
	 << "  using Miro::operator<<=;" << endl
	 << "  using Miro::operator>>=;" << endl
	 << "  using Miro::operator<<;" << endl
	 << "};" << endl
	 << endl;
  }

  QStringVector::const_iterator f, l = namespace_.end();
  for (f = namespace_.begin(); f != l; ++f) {
    ostr << spaces.left(indent) << "namespace " <<  *f << endl
	 << spaces.left(indent) << "{" << endl;
    indent += STEP;
  }

  ClassVector::const_iterator first, last = class_.end();
  for (first = class_.begin(); first != last; ++first) {
    if (first != class_.begin())
      ostr << endl;
    if (!first->isDummy())
      first->generateSource(ostr, indent);
  }

  while (indent) {
    indent -= STEP;
    ostr << spaces.left(indent) << "};" << endl;
  }

}

void
Generator::getGroupedClasses(const QString& _group, 
			     GroupMap::const_iterator& _first, GroupMap::const_iterator& _last) const
{
  _first = groups_.lower_bound(_group);
  _last = groups_.upper_bound(_group);
}

const Class *
Generator::getClass(const QString& _name) const
{
  ClassVector::const_iterator first, last = class_.end();
  for (first = class_.begin(); first != last; ++first)
    if (first->name() == _name)
      return first;
  return NULL;
}
